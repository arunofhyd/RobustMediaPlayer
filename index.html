<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="iExbroKtO4ZRq3ZjUsyY8JJowXvx-yHOy4yQq0iS6vY" />
    <title>Robust Media Player</title>

    <meta name="description" content="A versatile media player supporting local files, HLS streams, playlists, audio visualization, subtitle sync, and video filters.">
    <meta name="keywords" content="robust player, robust media player, rmp, media player, video player, audio player, local player, local media player, local video player with subs, subtitle customizer, VTT, SRT, local media">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://robustplayer.vercel.app/">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://robustplayer.vercel.app/">
    <meta property="og:title" content="Robust Media Player">
    <meta property="og:description" content="A versatile media player supporting local files, HLS streams, playlists, audio visualization, subtitle sync, and video filters.">
    <meta property="og:image" content="https://robustplayer.vercel.app/assets/logo.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://robustplayer.vercel.app/">
    <meta property="twitter:title" content="Robust Media Player">
    <meta property="twitter:description" content="A versatile media player supporting local files, HLS streams, playlists, audio visualization, subtitle sync, and video filters.">
    <meta property="twitter:image" content="https://robustplayer.vercel.app/assets/logo.png">

    <link rel="icon" href="assets/logo.png" sizes="any" type="image/png">
    <link rel="apple-touch-icon" href="assets/logo.png">
    <link rel="apple-touch-icon" sizes="76x76" href="assets/logo.png">
    <link rel="apple-touch-icon" sizes="120x120" href="assets/logo.png">
    <link rel="apple-touch-icon" sizes="152x152" href="assets/logo.png">
    <link rel="apple-touch-icon" sizes="180x180" href="assets/logo.png">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Robust Media Player">

    <meta name="application-name" content="Robust Media Player">
    <meta name="msapplication-TileImage" content="assets/logo.png">
    <meta name="msapplication-TileColor" content="#3b82f6">
    <meta name="theme-color" id="theme-color-meta" content="#3b82f6">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "url": "https://robustplayer.vercel.app/",
      "logo": "https://robustplayer.vercel.app/assets/logo.png"
    }
    </script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                container: {
                    center: true,
                    padding: "2rem",
                    screens: {
                        "2xl": "1400px",
                    },
                },
                extend: {
                    borderColor: {
                        DEFAULT: "hsl(var(--border))",
                    },
                    colors: {
                        border: "hsl(var(--border))",
                        input: "hsl(var(--input))",
                        ring: "hsl(var(--ring))",
                        background: "hsl(var(--background))",
                        foreground: "hsl(var(--foreground))",
                        primary: {
                            DEFAULT: "hsl(var(--primary))",
                            foreground: "hsl(var(--primary-foreground))",
                        },
                        secondary: {
                            DEFAULT: "hsl(var(--secondary))",
                            foreground: "hsl(var(--secondary-foreground))",
                        },
                        destructive: {
                            DEFAULT: "hsl(var(--destructive))",
                            foreground: "hsl(var(--destructive-foreground))",
                        },
                        muted: {
                            DEFAULT: "hsl(var(--muted))",
                            foreground: "hsl(var(--muted-foreground))",
                        },
                        accent: {
                            DEFAULT: "hsl(var(--accent))",
                            foreground: "hsl(var(--accent-foreground))",
                        },
                        popover: {
                            DEFAULT: "hsl(var(--popover))",
                            foreground: "hsl(var(--popover-foreground))",
                        },
                        card: {
                            DEFAULT: "hsl(var(--card))",
                            foreground: "hsl(var(--card-foreground))",
                        },
                    },
                    borderRadius: {
                        lg: "var(--radius)",
                        md: "calc(var(--radius) - 2px)",
                        sm: "calc(var(--radius) - 4px)",
                    },
                    fontFamily: {
                        sans: ["Inter", "sans-serif"],
                    }
                },
            },
        }
    </script>

    <link rel="preload"
          href="https://fonts.googleapis.com/css2?family=Fira+Sans&family=Inter:wght@400;500;600;700&family=Lato&family=Montserrat&family=Open+Sans&family=PT+Serif&family=Roboto&family=Source+Sans+Pro&display=swap"
          as="style"
          onload="this.onload=null;this.rel='stylesheet'">

    <style id="subtitle-style"></style>

    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 240 10% 3.9%;
            --card: 0 0% 100%;
            --card-foreground: 240 10% 3.9%;
            --popover: 0 0% 100%;
            --popover-foreground: 240 10% 3.9%;
            --primary: 240 5.9% 10%;
            --primary-foreground: 0 0% 98%;
            --secondary: 240 4.8% 95.9%;
            --secondary-foreground: 240 5.9% 10%;
            --muted: 240 4.8% 95.9%;
            --muted-foreground: 240 3.8% 46.1%;
            --accent: 240 4.8% 95.9%;
            --accent-foreground: 240 5.9% 10%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 0 0% 98%;
            --border: 240 5.9% 90%;
            --input: 240 5.9% 90%;
            --ring: 240 5.9% 10%;
            --radius: 0.5rem;
        }

        .dark {
            --background: 240 10% 3.9%;
            --foreground: 0 0% 98%;
            --card: 240 10% 3.9%;
            --card-foreground: 0 0% 98%;
            --popover: 240 10% 3.9%;
            --popover-foreground: 0 0% 98%;
            --primary: 0 0% 98%;
            --primary-foreground: 240 5.9% 10%;
            --secondary: 240 3.7% 15.9%;
            --secondary-foreground: 0 0% 98%;
            --muted: 240 3.7% 15.9%;
            --muted-foreground: 240 5% 64.9%;
            --accent: 240 3.7% 15.9%;
            --accent-foreground: 0 0% 98%;
            --destructive: 0 62.8% 30.6%;
            --destructive-foreground: 0 0% 98%;
            --border: 240 3.7% 15.9%;
            --input: 240 3.7% 15.9%;
            --ring: 240 4.9% 83.9%;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Custom scrollbar for webkit */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: hsl(var(--secondary));
        }
        ::-webkit-scrollbar-thumb {
            background: hsl(var(--muted-foreground));
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: hsl(var(--foreground));
        }

        /* Slider Reset and Styling */
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
        }
        input[type="range"]:focus {
            outline: none;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: hsl(var(--secondary));
            height: 0.5rem;
            border-radius: 9999px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: hsl(var(--primary));
            height: 1rem;
            width: 1rem;
            border-radius: 50%;
            margin-top: -0.25rem; /* Center thumb */
        }
        input[type="range"]::-moz-range-track {
            background: hsl(var(--secondary));
            height: 0.5rem;
            border-radius: 9999px;
        }
        input[type="range"]::-moz-range-thumb {
            background: hsl(var(--primary));
            height: 1rem;
            width: 1rem;
            border: none;
            border-radius: 50%;
        }

        /* Fade Animation (No movement) */
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

    </style>
</head>
<body class="bg-background text-foreground min-h-screen p-3 sm:p-8 flex flex-col items-center">

    <div id="app" class="w-full max-w-5xl space-y-4 sm:space-y-8" role="main">

        <!-- Header -->
        <header class="flex flex-col sm:flex-row items-center justify-between gap-3 sm:gap-4 fade-in">
            <div class="flex items-center gap-3">
                <img src="assets/logo.png"
                     alt="Robust Media Player Logo"
                     class="h-8 w-8 sm:h-10 sm:w-10 rounded-md shadow-sm"
                     aria-hidden="true"
                     onerror="this.style.display='none'">
                <div>
                    <h1 class="text-2xl sm:text-3xl font-bold tracking-tight">Robust Media Player</h1>
                    <p class="text-xs sm:text-sm text-muted-foreground">Load direct video/audio files or use external embeds.</p>
                </div>
            </div>

            <button id="themeToggle"
                    class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 hover:bg-accent hover:text-accent-foreground h-10 w-10 border border-input bg-background"
                    aria-label="Toggle Dark/Light Mode"
                    title="Toggle Dark/Light Mode">
                <i data-lucide="moon" class="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"></i>
                <i data-lucide="sun" class="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"></i>
            </button>
        </header>

        <!-- Main Content Wrapper -->
        <div class="flex flex-col xl:flex-row w-full gap-4 relative">

            <!-- Main Card -->
            <div id="mainCard" class="flex-grow rounded-xl border bg-card text-card-foreground shadow-sm fade-in min-w-0">

                <div class="p-4 sm:p-6 pt-0 space-y-4 sm:space-y-6">

                    <!-- Toast Container (Fixed Bottom Right/Center Mobile) -->
                <div id="toastContainer" class="fixed bottom-4 left-4 right-4 sm:left-auto sm:right-4 z-50 flex flex-col gap-2 pointer-events-none items-center sm:items-end"></div>

                <!-- Controls Grid -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6">

                    <!-- URL Input -->
                    <div class="md:col-span-2 space-y-2">
                        <label for="videoUrl" class="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">Video/Embed URL</label>
                        <div class="flex w-full items-center space-x-2">
                            <input type="text" id="videoUrl" list="urlHistory" placeholder="Enter link..."
                                   class="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50">
                            <datalist id="urlHistory"></datalist>
                            <button id="loadUrlBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2">
                                <span class="hidden sm:inline">Load</span>
                                <i data-lucide="arrow-right" class="h-4 w-4 sm:ml-2"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Local Media File -->
                    <div class="relative group cursor-pointer">
                         <div class="absolute inset-0 rounded-xl border-2 border-dashed border-muted-foreground/25 group-hover:border-primary/50 transition-colors pointer-events-none"></div>
                         <div class="flex flex-row items-center justify-center md:justify-start px-6 py-4 text-left gap-4 h-full">
                             <div class="p-2 rounded-full bg-secondary text-secondary-foreground group-hover:bg-primary/10 transition-colors shrink-0">
                                 <i data-lucide="file-video" class="h-6 w-6"></i>
                             </div>
                             <div class="space-y-1 min-w-0">
                                 <p class="text-sm font-medium truncate">Load Media</p>
                                 <p class="text-[10px] text-muted-foreground truncate">Video (.mp4, .mkv) & Audio (.mp3)</p>
                             </div>
                         </div>
                         <input type="file" id="videoFile" accept="video/*,audio/*,.ts" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                    </div>

                    <!-- Subtitle & Settings -->
                    <div class="flex space-x-2 h-full">
                         <!-- Subtitle File -->
                         <div class="relative group cursor-pointer flex-grow">
                            <div class="absolute inset-0 rounded-xl border-2 border-dashed border-muted-foreground/25 group-hover:border-primary/50 transition-colors pointer-events-none"></div>
                            <div class="flex flex-row items-center justify-center md:justify-start px-6 py-4 text-left gap-4 h-full">
                                <div class="p-2 rounded-full bg-secondary text-secondary-foreground group-hover:bg-primary/10 transition-colors shrink-0">
                                    <i data-lucide="file-type" class="h-6 w-6"></i>
                                </div>
                                <div class="space-y-1 min-w-0">
                                    <p class="text-sm font-medium truncate">Load Subtitles</p>
                                    <p class="text-[10px] text-muted-foreground truncate">.vtt, .srt</p>
                                </div>
                            </div>
                            <input type="file" id="subtitleFile" accept=".vtt,.srt" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                       </div>

                       <!-- Settings Toggle -->
                       <button id="settingsToggle"
                               class="inline-flex items-center justify-center rounded-xl border border-input bg-background hover:bg-accent hover:text-accent-foreground h-full w-14 transition-colors"
                               aria-label="Toggle Settings">
                           <i data-lucide="settings-2" class="h-6 w-6 transition-transform duration-300"></i>
                       </button>
                    </div>

                </div>

                <!-- Settings Panel -->
                <div id="settingsPanel" class="hidden rounded-lg border bg-card text-card-foreground shadow-sm animate-in fade-in"
                     role="region">
                    <div class="p-6 space-y-6">

                        <!-- Video Filters -->
                        <div class="space-y-3 pb-4 border-b border-border/50">
                             <h4 class="text-xs font-bold text-muted-foreground uppercase tracking-widest">Video Adjustments</h4>
                             <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                <div class="space-y-2">
                                    <label for="videoBrightness" class="text-xs font-medium text-muted-foreground flex justify-between">Brightness <span id="valBrightness">100%</span></label>
                                    <input type="range" id="videoBrightness" min="0" max="200" value="100" class="w-full h-2 bg-secondary rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div class="space-y-2">
                                    <label for="videoContrast" class="text-xs font-medium text-muted-foreground flex justify-between">Contrast <span id="valContrast">100%</span></label>
                                    <input type="range" id="videoContrast" min="0" max="200" value="100" class="w-full h-2 bg-secondary rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div class="space-y-2">
                                    <label for="videoSaturation" class="text-xs font-medium text-muted-foreground flex justify-between">Saturation <span id="valSaturation">100%</span></label>
                                    <input type="range" id="videoSaturation" min="0" max="200" value="100" class="w-full h-2 bg-secondary rounded-lg appearance-none cursor-pointer">
                                </div>
                             </div>
                        </div>

                        <!-- Subtitle Settings -->
                        <div class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="text-xs font-bold text-muted-foreground uppercase tracking-widest">Subtitles</h4>
                            </div>

                            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                                 <div class="space-y-2">
                                     <label for="subFontColor" class="text-xs font-medium text-muted-foreground">Font Color</label>
                                 <div class="flex items-center gap-2">
                                     <input type="color" id="subFontColor" value="#ffffff" class="h-9 w-full rounded-md border border-input cursor-pointer p-1 bg-background">
                                 </div>
                             </div>

                             <div class="space-y-2">
                                <label for="subFontFamily" class="text-xs font-medium text-muted-foreground">Font Family</label>
                                <select id="subFontFamily" class="flex h-9 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50">
                                    <option value="'Inter', sans-serif">Inter</option>
                                    <option value="'Roboto', sans-serif">Roboto</option>
                                    <option value="'Open Sans', sans-serif">Open Sans</option>
                                    <option value="'Lato', sans-serif">Lato</option>
                                    <option value="'Montserrat', sans-serif">Montserrat</option>
                                    <option value="'Courier New', monospace">Monospace</option>
                                </select>
                            </div>

                            <div class="space-y-2">
                                <label for="subFontSize" class="text-xs font-medium text-muted-foreground">Font Size: <span id="currentFontSize">24px</span></label>
                                <input type="range" id="subFontSize" min="2" max="100" value="24" step="1" class="w-full h-2 bg-secondary rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>

                        <div class="pt-4 border-t space-y-4">
                            <div>
                                <label for="subOffset" class="text-xs font-medium text-muted-foreground block mb-2">Subtitle Offset: <span id="currentSubOffset">0.0</span>s</label>
                                <input type="range" id="subOffset" min="-60" max="60" value="0.0" step="0.1" class="w-full h-2 bg-secondary rounded-lg appearance-none cursor-pointer">
                            </div>
                            
                            <div class="bg-secondary/50 rounded-lg p-3 space-y-2">
                                <label class="text-xs font-medium text-muted-foreground block">Quick Sync</label>
                                <p class="text-[10px] text-muted-foreground">Click when you hear the specific line.</p>
                                <div class="grid grid-cols-2 gap-2">
                                    <button id="syncSubStartBtn" class="bg-background border rounded px-2 py-1.5 text-xs hover:bg-accent transition-colors text-left truncate">
                                        Wait for first sub...
                                    </button>
                                </div>
                            </div>

                            <div class="w-full flex justify-center">
                                <button id="resetSettingsBtn" class="text-xs text-red-500 hover:text-red-600 font-medium underline">Reset to Defaults</button>
                            </div>
                        </div>
                    </div>
                </div>
                </div>

                <!-- Media Player Container -->
                <div class="relative w-full aspect-video rounded-lg overflow-hidden border bg-black shadow-lg group">

                    <!-- Audio Visualizer Canvas -->
                    <canvas id="audioVisualizer" class="absolute inset-0 w-full h-full pointer-events-none z-10 opacity-90"></canvas>

                    <!-- Subtitle Demo -->
                    <div id="subtitleDemo" class="absolute z-50 bottom-8 left-1/2 transform -translate-x-1/2 pointer-events-none transition-opacity duration-300 hidden">
                        <span id="demoText" class="px-2 py-1 rounded">The quick brown fox jumps over the lazy dog</span>
                    </div>

                    <!-- Drag Drop Overlay -->
                    <div id="dragDropOverlay" class="absolute inset-0 z-20 hidden flex-col items-center justify-center bg-background/80 backdrop-blur-sm border-2 border-dashed border-primary transition-all pointer-events-none">
                         <i data-lucide="upload-cloud" class="h-16 w-16 text-primary mb-4"></i>
                         <p class="text-2xl font-bold text-foreground">Drop File Here</p>
                    </div>

                    <!-- Overlay Controls (Top Right) -->
                    <div id="overlayControls" class="absolute top-3 right-3 sm:top-4 sm:right-4 z-[60] flex items-center gap-2 opacity-100 sm:opacity-0 sm:group-hover:opacity-100 transition-opacity">
                         <button id="screenshotBtn" class="p-2 sm:p-2.5 rounded-full bg-black/50 hover:bg-white/20 text-white backdrop-blur-sm transition-all shadow-md hover:scale-105 focus:scale-105 focus:outline-none" aria-label="Take Screenshot" title="Take Screenshot">
                            <i data-lucide="camera" class="h-5 w-5 sm:h-6 sm:w-6"></i>
                        </button>
                         <button id="pipToggle" class="hidden p-2 sm:p-2.5 rounded-full bg-black/50 hover:bg-white/20 text-white backdrop-blur-sm transition-all shadow-md hover:scale-105 focus:scale-105 focus:outline-none" aria-label="Toggle Picture-in-Picture" title="Picture-in-Picture">
                            <i data-lucide="picture-in-picture-2" class="h-5 w-5 sm:h-6 sm:w-6"></i>
                        </button>
                        <button id="loopToggle" class="p-2 sm:p-2.5 rounded-full bg-black/50 hover:bg-white/20 text-white backdrop-blur-sm transition-all shadow-md hover:scale-105 focus:scale-105 focus:outline-none" aria-label="Playback Mode" title="Mode: Normal">
                            <i data-lucide="arrow-right-circle" class="h-5 w-5 sm:h-6 sm:w-6"></i>
                        </button>
                        <button id="fullscreenToggle" class="p-2 sm:p-2.5 rounded-full bg-black/50 hover:bg-white/20 text-white backdrop-blur-sm transition-all shadow-md hover:scale-105 focus:scale-105 focus:outline-none" aria-label="Toggle Fullscreen" title="Fullscreen">
                            <i data-lucide="maximize" class="h-5 w-5 sm:h-6 sm:w-6"></i>
                        </button>
                    </div>

                    <!-- Feedback Indicator -->
                    <div id="feedbackIndicator" class="absolute inset-0 flex items-center justify-center pointer-events-none z-30 opacity-0 transition-opacity duration-300">
                        <div class="bg-background/50 backdrop-blur-md text-foreground rounded-full p-6 shadow-xl border border-border">
                            <!-- Icon injected via JS -->
                            <div id="indicatorIconWrapper"></div>
                        </div>
                    </div>

                    <video id="videoPlayer" controls preload="auto" crossorigin="anonymous" class="w-full h-full object-contain" poster="https://placehold.co/800x450/09090b/e4e4e7?text=Ready+to+Load+Media"></video>

                    <iframe id="iframePlayer" class="w-full h-full hidden" allowfullscreen allow="autoplay"></iframe>
                </div>

                </div>
            </div>

            <!-- Playlist Sidebar -->
            <div id="playlistSidebar" class="hidden flex-col w-full xl:w-80 shrink-0 bg-card border rounded-xl shadow-sm h-96 xl:h-[600px] xl:sticky xl:top-4 fade-in overflow-hidden">
                <div class="p-4 border-b flex items-center justify-between">
                    <h3 class="font-semibold flex items-center gap-2">
                        <i data-lucide="list-video" class="h-5 w-5"></i>
                        Playlist
                    </h3>
                    <span id="playlistCount" class="text-xs bg-secondary px-2 py-1 rounded-full text-muted-foreground">0</span>
                </div>
                <div id="playlistContainer" class="flex-1 overflow-y-auto p-2 space-y-1">
                    <div class="text-center p-8 text-muted-foreground text-sm">
                        <i data-lucide="ghost" class="h-8 w-8 mx-auto mb-2 opacity-50"></i>
                        <p>Drop multiple files to create a queue</p>
                    </div>
                </div>
            </div>

        </div>

        <footer class="text-center pb-8 flex flex-col items-center gap-4 mt-8">
            <div class="flex items-center gap-4">
                <button id="playlistToggleBtn" class="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-primary transition-colors">
                    <i data-lucide="list-video" class="h-4 w-4"></i>
                    <span>Playlist</span>
                </button>
                <span class="text-muted-foreground/30">|</span>
                <button id="helpBtn" class="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-primary transition-colors">
                    <i data-lucide="keyboard" class="h-4 w-4"></i>
                    <span>Shortcuts</span>
                </button>
                <span class="text-muted-foreground/30">|</span>
                <a href="mailto:arunthomas04042001@gmail.com" class="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-primary transition-colors">
                    <i data-lucide="mail" class="h-4 w-4"></i>
                    <span>Contact Developer</span>
                </a>
            </div>
        </footer>

        <!-- Help Modal -->
        <div id="helpModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-background/80 backdrop-blur-sm p-4 animate-in fade-in">
             <div class="w-full max-w-md rounded-xl border bg-card p-6 shadow-lg relative">
                 <button id="closeHelpBtn" class="absolute top-4 right-4 text-muted-foreground hover:text-foreground">
                     <i data-lucide="x" class="h-5 w-5"></i>
                 </button>
                 <h3 class="text-lg font-semibold mb-4 flex items-center gap-2">
                     <i data-lucide="keyboard" class="h-5 w-5"></i>
                     Keyboard Shortcuts
                 </h3>
                 <div class="space-y-3">
                     <div class="flex justify-between text-sm">
                         <span class="text-muted-foreground">Play / Pause</span>
                         <span class="font-mono bg-secondary px-2 py-0.5 rounded text-xs">Space</span>
                     </div>
                     <div class="flex justify-between text-sm">
                         <span class="text-muted-foreground">Seek Forward / Backward</span>
                         <span class="font-mono bg-secondary px-2 py-0.5 rounded text-xs">← / →</span>
                     </div>
                     <div class="flex justify-between text-sm">
                         <span class="text-muted-foreground">Volume Up / Down</span>
                         <span class="font-mono bg-secondary px-2 py-0.5 rounded text-xs">↑ / ↓</span>
                     </div>
                     <div class="flex justify-between text-sm">
                         <span class="text-muted-foreground">Mute</span>
                         <span class="font-mono bg-secondary px-2 py-0.5 rounded text-xs">M</span>
                     </div>
                     <div class="flex justify-between text-sm">
                         <span class="text-muted-foreground">Fullscreen</span>
                         <span class="font-mono bg-secondary px-2 py-0.5 rounded text-xs">F</span>
                     </div>
                 </div>
             </div>
        </div>

    </div>

    <script>
        // --- Initialization of Lucide Icons ---
        lucide.createIcons();

        // --- Core Application Logic ---
        const videoPlayer = document.getElementById('videoPlayer');
        const iframePlayer = document.getElementById('iframePlayer');
        const videoUrlInput = document.getElementById('videoUrl');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        const videoFileInput = document.getElementById('videoFile');
        const subtitleFileInput = document.getElementById('subtitleFile');
        // const statusMessage = document.getElementById('statusMessage'); // Removed
        const toastContainer = document.getElementById('toastContainer');
        const mainCard = document.getElementById('mainCard');
        const dragDropOverlay = document.getElementById('dragDropOverlay');
        const themeToggle = document.getElementById('themeToggle');
        const loopToggle = document.getElementById('loopToggle');
        const feedbackIndicator = document.getElementById('feedbackIndicator');
        const indicatorIconWrapper = document.getElementById('indicatorIconWrapper');

        const subtitleStyleSheet = document.getElementById('subtitle-style');

        // Settings DOM elements
        const settingsToggle = document.getElementById('settingsToggle');
        const settingsPanel = document.getElementById('settingsPanel');
        const pipToggle = document.getElementById('pipToggle');
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        const screenshotBtn = document.getElementById('screenshotBtn');
        const resetSettingsBtn = document.getElementById('resetSettingsBtn');

        // Help Modal Elements
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeHelpBtn = document.getElementById('closeHelpBtn');
        const playlistToggleBtn = document.getElementById('playlistToggleBtn');

        // Audio Visualizer Elements
        const canvas = document.getElementById('audioVisualizer');
        const canvasCtx = canvas.getContext('2d');

        // Playlist Elements
        const playlistSidebar = document.getElementById('playlistSidebar');
        const playlistContainer = document.getElementById('playlistContainer');
        const playlistCount = document.getElementById('playlistCount');

        // Demo elements
        const subtitleDemo = document.getElementById('subtitleDemo');
        const demoText = document.getElementById('demoText');

        // Input elements
        const subFontColorInput = document.getElementById('subFontColor');
        const subFontSizeInput = document.getElementById('subFontSize');
        const subFontFamilyInput = document.getElementById('subFontFamily');
        const subOffsetInput = document.getElementById('subOffset');
        const syncSubStartBtn = document.getElementById('syncSubStartBtn');

        // Video Filter Inputs
        const videoBrightnessInput = document.getElementById('videoBrightness');
        const videoContrastInput = document.getElementById('videoContrast');
        const videoSaturationInput = document.getElementById('videoSaturation');
        const valBrightness = document.getElementById('valBrightness');
        const valContrast = document.getElementById('valContrast');
        const valSaturation = document.getElementById('valSaturation');

        const currentFontSizeSpan = document.getElementById('currentFontSize');
        const currentSubOffsetSpan = document.getElementById('currentSubOffset');

        // --- State Management ---
        let feedbackTimeout;
        let currentVideoBlobUrl = null;
        let currentMediaId = null; // For resume functionality
        let hls;
        let originalCues = [];
        let activeTrack = null;
        let playbackMode = 'normal'; // normal, loop-one, loop-all, shuffle
        const SUB_SETTINGS_KEY = 'subtitleSettings';
        const URL_HISTORY_KEY = 'urlHistory';

        // Audio Context State
        let audioCtx;
        let audioSource;
        let analyser;
        let isVisualizerRunning = false;
        let visualizerStyle = 'bars';
        let visualizerHue = 217; // Default Blue
        let visualizerSaturation = 80;
        let visualizerLightness = 60;
        let isAudioFile = false;

        // Playlist State
        let playlist = [];
        let currentPlaylistIndex = -1;

        // PiP State
        let pipVideo = null;

        // --- Theme Toggle Logic ---
        function setTheme(theme) {
            const root = document.documentElement;
            if (theme === 'light') {
                root.classList.remove('dark');
                localStorage.setItem('theme', 'light');
            } else {
                root.classList.add('dark');
                localStorage.setItem('theme', 'dark');
            }
        }

        themeToggle.addEventListener('click', () => {
            const isDark = document.documentElement.classList.contains('dark');
            setTheme(isDark ? 'light' : 'dark');
        });

        // Initialize theme
        const storedTheme = localStorage.getItem('theme');
        if (storedTheme) {
            setTheme(storedTheme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
            setTheme('light');
        } else {
            setTheme('dark');
        }

        // --- Loop/Shuffle Logic ---
        const playbackModes = ['normal', 'loop-one', 'loop-all', 'shuffle'];
        
        loopToggle.addEventListener('click', () => {
            const currentIndex = playbackModes.indexOf(playbackMode);
            const nextIndex = (currentIndex + 1) % playbackModes.length;
            playbackMode = playbackModes[nextIndex];
            updatePlaybackModeUI();
        });

        function updatePlaybackModeUI() {
            let iconName = 'arrow-right-circle';
            let title = 'Mode: Normal';
            let active = false;

            videoPlayer.loop = false; // Reset native loop

            switch(playbackMode) {
                case 'normal':
                    iconName = 'arrow-right-circle';
                    title = 'Mode: Normal';
                    active = false;
                    break;
                case 'loop-one':
                    iconName = 'repeat-1';
                    title = 'Mode: Loop One';
                    active = true;
                    videoPlayer.loop = true;
                    break;
                case 'loop-all':
                    iconName = 'repeat';
                    title = 'Mode: Loop All';
                    active = true;
                    break;
                case 'shuffle':
                    iconName = 'shuffle';
                    title = 'Mode: Shuffle';
                    active = true;
                    break;
            }

            // Update Icon
            loopToggle.innerHTML = `<i data-lucide="${iconName}" class="h-5 w-5 sm:h-6 sm:w-6"></i>`;
            lucide.createIcons({ root: loopToggle });
            loopToggle.title = title;

            // Update Style
            if (active) {
                loopToggle.classList.remove('bg-black/50', 'text-white');
                loopToggle.classList.add('bg-primary', 'text-primary-foreground');
            } else {
                loopToggle.classList.remove('bg-primary', 'text-primary-foreground');
                loopToggle.classList.add('bg-black/50', 'text-white');
            }
            
            showTemporaryAlert(title, 'info');
        }

        // --- Subtitle Logic ---
        function loadSubtitleSettings() {
            const savedSettings = localStorage.getItem(SUB_SETTINGS_KEY);
            const defaultSettings = {
                fontColor: '#ffffff',
                fontSize: '24px',
                fontFamily: "'Inter', sans-serif",
                subOffset: 0.0,
            };
            const settings = savedSettings ? JSON.parse(savedSettings) : defaultSettings;

            if (savedSettings && settings.bgColor) {
                delete settings.bgColor;
                delete settings.bgOpacity;
                localStorage.setItem(SUB_SETTINGS_KEY, JSON.stringify(settings));
            }

            subFontColorInput.value = settings.fontColor;
            const sizeInPixels = parseInt(settings.fontSize.replace('px', '')) || 24;
            subFontSizeInput.value = Math.max(2, Math.min(100, sizeInPixels));
            subOffsetInput.value = parseFloat(settings.subOffset) || 0.0;
            subFontFamilyInput.value = settings.fontFamily;

            applySubtitleStyles();
            applySubtitleOffset();
            demoText.textContent = "The quick brown fox jumps over the lazy dog";
        }

        function applySubtitleStyles() {
            const rawFontSize = subFontSizeInput.value;
            const rawOffset = parseFloat(subOffsetInput.value).toFixed(1);

            const settings = {
                fontColor: subFontColorInput.value,
                fontSize: rawFontSize + 'px',
                fontFamily: subFontFamilyInput.value,
                subOffset: rawOffset,
            };

            if(currentFontSizeSpan) currentFontSizeSpan.textContent = settings.fontSize;
            if(currentSubOffsetSpan) currentSubOffsetSpan.textContent = rawOffset;

            localStorage.setItem(SUB_SETTINGS_KEY, JSON.stringify(settings));

            const cssRule = `
                video::cue {
                    color: ${settings.fontColor} !important;
                    background-color: transparent !important;
                    font-size: ${settings.fontSize} !important;
                    font-family: ${settings.fontFamily} !important;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                    padding: 0 !important;
                    border-radius: 0 !important;
                }
            `;
            subtitleStyleSheet.textContent = cssRule;

            const proportionalSize = (parseInt(rawFontSize) / 100) * 5;
            const demoFontSize = Math.max(0.5, Math.min(6.0, proportionalSize));

            demoText.style.color = settings.fontColor;
            demoText.style.backgroundColor = 'transparent';
            demoText.style.fontSize = demoFontSize + 'vw';
            demoText.style.fontFamily = settings.fontFamily;
            demoText.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.8)';
            demoText.style.display = 'inline-block';
            demoText.style.padding = '0';
            demoText.style.borderRadius = '0';

            applySubtitleOffset();
        }

        function applySubtitleOffset() {
            const offset = parseFloat(subOffsetInput.value);
            currentSubOffsetSpan.textContent = offset.toFixed(1);

            const tracks = videoPlayer.textTracks;
            let currentTrack = null;

            for (let i = 0; i < tracks.length; i++) {
                if (tracks[i].mode === 'showing' || tracks[i].default) {
                    currentTrack = tracks[i];
                    break;
                }
            }

            if (!currentTrack) return;

            if (currentTrack !== activeTrack || originalCues.length === 0) {
                if (currentTrack.cues && currentTrack.cues.length > 0) {
                    originalCues = Array.from(currentTrack.cues).map(cue => ({
                        start: cue.startTime,
                        end: cue.endTime,
                        text: cue.text
                    }));
                    activeTrack = currentTrack;
                } else {
                    currentTrack.addEventListener('load', applySubtitleOffset, { once: true });
                    return;
                }
            }

            while(currentTrack.cues.length > 0) {
                currentTrack.removeCue(currentTrack.cues[0]);
            }

            originalCues.forEach(cueData => {
                const newStartTime = Math.max(0, cueData.start + offset);
                const newEndTime = Math.max(newStartTime, cueData.end + offset);
                const newCue = new VTTCue(newStartTime, newEndTime, cueData.text);
                currentTrack.addCue(newCue);
            });
            currentTrack.mode = 'showing';
            
            // Update Sync Button Text
            if (originalCues.length > 0) {
                const firstCue = originalCues[0];
                syncSubStartBtn.textContent = `Sync to: "${firstCue.text.substring(0, 15)}..."`;
                syncSubStartBtn.onclick = () => {
                    const currentVidTime = videoPlayer.currentTime;
                    // We want firstCue.start + offset = currentVidTime
                    // So offset = currentVidTime - firstCue.start
                    const newOffset = currentVidTime - firstCue.start;
                    subOffsetInput.value = newOffset.toFixed(1);
                    applySubtitleStyles();
                    showTemporaryAlert(`Synced to ${formatTime(currentVidTime)}`, 'success');
                };
            }
        }

        [subFontColorInput, subFontFamilyInput, subFontSizeInput, subOffsetInput].forEach(input => {
            const eventType = input.type === 'range' ? 'input' : 'change';
            input.addEventListener(eventType, applySubtitleStyles);
        });

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function toggleSettings() {
            const isHidden = settingsPanel.classList.toggle('hidden');

            // Re-render icon with rotation
            if (isHidden) {
                // Not rotated
                 settingsToggle.innerHTML = '<i data-lucide="settings-2" class="h-6 w-6 transition-transform duration-300"></i>';
            } else {
                // Rotated
                 settingsToggle.innerHTML = '<i data-lucide="settings-2" class="h-6 w-6 transition-transform duration-300 rotate-180"></i>';
            }
            lucide.createIcons();

            subtitleDemo.classList.toggle('hidden', isHidden);
            settingsToggle.setAttribute('aria-expanded', !isHidden);
        }

        settingsToggle.addEventListener('click', toggleSettings);

        // Picture-in-Picture
        if (document.pictureInPictureEnabled && pipToggle) {
             pipToggle.classList.remove('hidden');
             pipToggle.addEventListener('click', async () => {
                 try {
                     if (document.pictureInPictureElement) {
                         await document.exitPictureInPicture();
                         return;
                     }

                     if (isAudioFile) {
                         // Audio Visualizer PiP Logic
                         if (!pipVideo) {
                             pipVideo = document.createElement('video');
                             // Invisible but rendered element for PiP support
                             pipVideo.style.position = 'fixed';
                             pipVideo.style.top = '0';
                             pipVideo.style.left = '0';
                             pipVideo.style.width = '1px';
                             pipVideo.style.height = '1px';
                             pipVideo.style.opacity = '0';
                             pipVideo.style.pointerEvents = 'none';
                             pipVideo.style.zIndex = '-50';
                             pipVideo.muted = true;
                             pipVideo.playsInline = true;
                             document.body.appendChild(pipVideo);

                             // Sync Logic (PiP -> Main)
                             pipVideo.addEventListener('play', () => {
                                 if (videoPlayer.paused) videoPlayer.play();
                             });
                             pipVideo.addEventListener('pause', () => {
                                 if (!videoPlayer.paused && document.pictureInPictureElement === pipVideo) {
                                     videoPlayer.pause();
                                 }
                             });

                             // Sync Logic (Main -> PiP)
                             videoPlayer.addEventListener('play', () => {
                                 if (document.pictureInPictureElement === pipVideo && pipVideo.paused) pipVideo.play();
                             });
                             videoPlayer.addEventListener('pause', () => {
                                 if (document.pictureInPictureElement === pipVideo && !pipVideo.paused) pipVideo.pause();
                             });

                             pipVideo.addEventListener('leavepictureinpicture', () => {
                                 pipVideo.pause();
                                 // Stop tracks to save resources
                                 if (pipVideo.srcObject) {
                                     pipVideo.srcObject.getTracks().forEach(track => track.stop());
                                     pipVideo.srcObject = null;
                                 }
                             });
                         }

                         // Capture Stream from Canvas (30 FPS)
                         const stream = canvas.captureStream(30);
                         pipVideo.srcObject = stream;
                         await pipVideo.play();
                         await pipVideo.requestPictureInPicture();

                         // Sync initial state
                         if (videoPlayer.paused) pipVideo.pause();

                     } else {
                         // Standard Video PiP
                         await videoPlayer.requestPictureInPicture();
                     }
                 } catch (err) {
                     console.error('PiP Error:', err);
                     showTemporaryAlert('PiP failed: ' + err.message, 'error');
                 }
             });
        }

        // Fullscreen Logic
        fullscreenToggle.addEventListener('click', () => {
            const container = videoPlayer.parentElement;
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => {
                    showTemporaryAlert(`Error attempting to enable fullscreen: ${err.message} (${err.name})`, 'error');
                });
            } else {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                fullscreenToggle.innerHTML = '<i data-lucide="minimize" class="h-5 w-5 sm:h-6 sm:w-6"></i>';
                fullscreenToggle.title = "Exit Fullscreen";
            } else {
                fullscreenToggle.innerHTML = '<i data-lucide="maximize" class="h-5 w-5 sm:h-6 sm:w-6"></i>';
                fullscreenToggle.title = "Fullscreen";
            }
            lucide.createIcons({ root: fullscreenToggle });
        });

        // Screenshot Logic
        screenshotBtn.addEventListener('click', () => {
            if (videoPlayer.style.display === 'none' || !videoPlayer.src) {
                showTemporaryAlert('Load a video first.', 'error');
                return;
            }

            const canvas = document.createElement('canvas');
            canvas.width = videoPlayer.videoWidth;
            canvas.height = videoPlayer.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);

            try {
                const dataUrl = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = `screenshot_${Date.now()}.png`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showTemporaryAlert('Screenshot saved.', 'success');
            } catch (err) {
                showTemporaryAlert('Screenshot failed (CORS/Security).', 'error');
            }
        });


        // --- Helper Functions ---
        function showTemporaryAlert(message, type) {
            // Create a new toast element
            const toast = document.createElement('div');
            toast.className = 'flex items-center gap-3 px-4 py-3 rounded-lg border shadow-lg bg-background text-sm font-medium animate-in slide-in-from-right-full transition-all duration-300 pointer-events-auto';

            // Add border/text colors based on type
            let iconName = 'info';
            if (type === 'error') {
                toast.classList.add('border-destructive/50', 'text-destructive');
                iconName = 'alert-triangle';
            } else if (type === 'success') {
                toast.classList.add('border-green-500/50', 'text-green-600', 'dark:text-green-400');
                iconName = 'check-circle';
            } else {
                toast.classList.add('border-border', 'text-foreground');
                iconName = 'info';
            }

            // Inner HTML structure with Icon and Message
            toast.innerHTML = `
                <i data-lucide="${iconName}" class="h-4 w-4"></i>
                <span>${message}</span>
            `;

            // Append to container
            toastContainer.appendChild(toast);
            lucide.createIcons({ root: toast }); // Initialize icon in new element

            // Remove after 3 seconds
            setTimeout(() => {
                toast.classList.add('opacity-0', 'translate-x-full');
                setTimeout(() => {
                    toast.remove();
                }, 300); // Wait for transition
            }, 3000);
        }

        function clearTracks() {
            const tracks = videoPlayer.querySelectorAll('track');
            tracks.forEach(track => {
                if (track.src.startsWith('blob:')) URL.revokeObjectURL(track.src);
                track.remove();
            });
            originalCues = [];
            activeTrack = null;
        }

        function setPlayerMode(mode) {
            const overlayControls = document.getElementById('overlayControls');
            if (mode === 'video') {
                videoPlayer.style.display = 'block';
                iframePlayer.style.display = 'none';
                iframePlayer.src = '';
                dragDropOverlay.classList.remove('pointer-events-none');
                if (overlayControls) overlayControls.classList.remove('hidden');
            } else if (mode === 'iframe') {
                videoPlayer.style.display = 'none';
                videoPlayer.pause();
                videoPlayer.removeAttribute('src');
                videoPlayer.load();
                videoPlayer.poster = 'https://placehold.co/800x450/09090b/e4e4e7?text=External+Embed+Loaded';
                clearTracks();
                iframePlayer.style.display = 'block';
                dragDropOverlay.classList.add('pointer-events-none');
                if (overlayControls) overlayControls.classList.add('hidden');
                if (currentVideoBlobUrl) URL.revokeObjectURL(currentVideoBlobUrl);
                currentVideoBlobUrl = null;
            }
            if (!subtitleDemo.classList.contains('hidden')) subtitleDemo.classList.add('hidden');
        }

        function srtToVtt(srtText) {
            const vttBody = srtText.replace(/(\d{2}:\d{2}:\d{2}),(\d{3})/g, '$1.$2');
            return 'WEBVTT\n\n' + vttBody;
        }

        function convertYouTubeLink(url) {
            // Match youtube.com/watch?v=ID, youtu.be/ID, youtube.com/embed/ID
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            if (match && match[2].length === 11) {
                return `https://www.youtube.com/embed/${match[2]}?autoplay=1`;
            }
            return url;
        }

        function loadMediaSource(src, fileName = null) {
            src = src ? src.trim() : '';
            if (src && !src.startsWith('http') && !src.startsWith('blob:')) src = 'https://' + src;

            if (hls) {
                hls.destroy();
                hls = null;
            }

            // Helper to safely revoke old blob if not in playlist
            const safelyRevokeBlob = (blobUrl) => {
                if (blobUrl && blobUrl.startsWith('blob:')) {
                    const isInPlaylist = playlist.some(item => item.url === blobUrl);
                    if (!isInPlaylist) {
                        URL.revokeObjectURL(blobUrl);
                    }
                }
            };

            if (!src) {
                safelyRevokeBlob(currentVideoBlobUrl);
                setPlayerMode('video');
                videoPlayer.src = '';
                videoPlayer.poster = 'https://placehold.co/800x450/09090b/e4e4e7?text=No+Media+Loaded';
                showTemporaryAlert('Media source cleared.', 'info');
                videoPlayer.load();
                currentMediaId = null;
                return;
            }

            // Generate ID for Resume
            if (fileName) {
                currentMediaId = 'local_' + fileName;
            } else {
                currentMediaId = 'url_' + src;
            }

            const isBlobUrl = src.startsWith('blob:');
            const isTsFile = (fileName && fileName.toLowerCase().endsWith('.ts')) || src.toLowerCase().includes('.ts');
            const mediaExtensions = /\.(mp4|webm|ogg|mov|avi|m4v|flv|f4v|mkv|wmv|mp3|wav|flac|m4a)$/i;
            const urlWithoutQuery = src.split('?')[0];
            const isDirectMediaFile = mediaExtensions.test(urlWithoutQuery) || (isBlobUrl && !isTsFile);

            // Check for YouTube specifically or other external links
            const isYouTube = src.includes('youtube.com') || src.includes('youtu.be');
            const isExternalLink = src.startsWith('http');

            // Detect Audio File
            const audioExtensions = /\.(mp3|wav|flac|m4a|aac|ogg)$/i;
            isAudioFile = (fileName && audioExtensions.test(fileName)) || audioExtensions.test(urlWithoutQuery);
            
            // Toggle Visualizer Visibility
            if (isAudioFile) {
                canvas.classList.remove('hidden');
                canvas.classList.add('opacity-100');
                canvas.classList.remove('opacity-90');
                // Removed logo poster to show visualizer clearly on black background
                videoPlayer.poster = ''; 
                randomizeVisualizer();
            } else {
                canvas.classList.add('hidden');
                isVisualizerRunning = false;
            }

            if (isTsFile && typeof Hls !== 'undefined' && Hls.isSupported()) {
                setPlayerMode('video');
                if (currentVideoBlobUrl && currentVideoBlobUrl !== src) safelyRevokeBlob(currentVideoBlobUrl);
                currentVideoBlobUrl = isBlobUrl ? src : null;

                hls = new Hls();
                hls.loadSource(src);
                hls.attachMedia(videoPlayer);
                hls.on(Hls.Events.MANIFEST_PARSED, function() {
                    videoPlayer.play();
                });
                videoPlayer.poster = '';
                showTemporaryAlert('Loaded .ts file via HLS.js.', 'success');
            } else if (isDirectMediaFile) {
                setPlayerMode('video');
                if (currentVideoBlobUrl && currentVideoBlobUrl !== src) safelyRevokeBlob(currentVideoBlobUrl);
                currentVideoBlobUrl = isBlobUrl ? src : null;

                videoPlayer.removeAttribute('src');
                videoPlayer.src = src;
                videoPlayer.load();
                if (!isAudioFile) videoPlayer.poster = '';
                showTemporaryAlert('Media loaded successfully.', 'success');
            } else if (isYouTube) {
                // Special handling for YouTube
                safelyRevokeBlob(currentVideoBlobUrl);
                currentVideoBlobUrl = null;
                setPlayerMode('iframe');
                iframePlayer.src = convertYouTubeLink(src);
                currentMediaId = null; // Can't resume iframe
                showTemporaryAlert('YouTube video loaded.', 'success');
            } else if (isExternalLink) {
                safelyRevokeBlob(currentVideoBlobUrl);
                currentVideoBlobUrl = null;
                setPlayerMode('iframe');
                iframePlayer.src = src;
                currentMediaId = null; // Can't resume iframe
                showTemporaryAlert('External embed loaded.', 'info');
            } else {
                setPlayerMode('video');
                videoPlayer.src = '';
                videoPlayer.poster = 'https://placehold.co/800x450/cc3333/ffffff?text=Invalid+Input';
                videoPlayer.load();
                showTemporaryAlert('Error: Invalid URL or Format.', 'error');
                currentMediaId = null;
                return; // Don't save history for invalid
            }

            // Save to history if it's a URL
            if (!fileName && src) {
                saveUrlToHistory(src);
            }
        }

        function saveUrlToHistory(url) {
            let history = JSON.parse(localStorage.getItem(URL_HISTORY_KEY) || '[]');
            if (!history.includes(url)) {
                history.unshift(url);
                if (history.length > 10) history.pop();
                localStorage.setItem(URL_HISTORY_KEY, JSON.stringify(history));
                updateHistoryDatalist();
            }
        }

        function updateHistoryDatalist() {
            const history = JSON.parse(localStorage.getItem(URL_HISTORY_KEY) || '[]');
            const datalist = document.getElementById('urlHistory');
            datalist.innerHTML = '';
            history.forEach(url => {
                const option = document.createElement('option');
                option.value = url;
                datalist.appendChild(option);
            });
        }
        
        // Init History
        updateHistoryDatalist();

        function processSubtitleFile(file) {
            if (videoPlayer.style.display === 'none' || !videoPlayer.src) {
                showTemporaryAlert('Load a video first.', 'error');
                subtitleFileInput.value = null;
                return;
            }
            const fileName = file.name.toLowerCase();
            let mimeType = 'text/vtt';
            let fileType = '';

            if (fileName.endsWith('.vtt')) fileType = 'WebVTT';
            else if (fileName.endsWith('.srt')) fileType = 'SubRip';
            else {
                showTemporaryAlert('Only .vtt and .srt supported.', 'error');
                subtitleFileInput.value = null;
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                let textContent = e.target.result;
                try {
                    if (fileType === 'SubRip') textContent = srtToVtt(textContent);
                    const subtitleBlob = new Blob([textContent], { type: mimeType });
                    const subtitleUrl = URL.createObjectURL(subtitleBlob);

                    clearTracks();
                    const track = document.createElement('track');
                    track.kind = 'subtitles';
                    track.label = `Local (${fileType})`;
                    track.srclang = 'en';
                    track.src = subtitleUrl;
                    track.default = true;
                    videoPlayer.appendChild(track);

                    track.addEventListener('load', () => {
                        showTemporaryAlert('Subtitle loaded.', 'success');
                        activeTrack = track.track;
                        applySubtitleOffset();
                    }, { once: true });
                } catch (error) {
                    showTemporaryAlert('Error processing subtitle.', 'error');
                }
                subtitleFileInput.value = null;
            };
            reader.readAsText(file);
        }

        // --- Event Listeners ---
        loadUrlBtn.addEventListener('click', () => {
            loadMediaSource(videoUrlInput.value.trim());
            videoFileInput.value = '';
        });

        videoFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                loadMediaSource(URL.createObjectURL(file), file.name);
                videoUrlInput.value = '';
            }
        });

        subtitleFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) processSubtitleFile(file);
        });

        videoPlayer.addEventListener('error', (e) => {
            // CORS Retry Logic
            if (videoPlayer.getAttribute('crossorigin') === 'anonymous') {
                console.warn("Video failed to load with CORS. Retrying without CORS (Visualizer/Screenshot disabled).");
                videoPlayer.removeAttribute('crossorigin');
                videoPlayer.load();
                // Prevent infinite loop if it fails again is handled by the browser not firing error again for same error state immediately or just failing hard
                // Ideally we'd remove this listener or add a flag, but for simple retry:
                return; 
            }
            videoPlayer.poster = 'https://placehold.co/800x450/cc3333/ffffff?text=Media+Loading+Failed';
            showTemporaryAlert('Media failed to load.', 'error');
        });

        videoPlayer.addEventListener('loadedmetadata', () => {
             // Reset visualizer state on new media
             isVisualizerRunning = false;
             
             if (currentMediaId) {
                 const savedTime = localStorage.getItem('resume_' + currentMediaId);
                 if (savedTime && parseFloat(savedTime) > 5) {
                     videoPlayer.currentTime = parseFloat(savedTime);
                     showTemporaryAlert('Resumed at ' + formatTime(savedTime), 'info');
                 }
             }
        });

        let lastSavedTime = 0;
        videoPlayer.addEventListener('timeupdate', () => {
            if (currentMediaId && !videoPlayer.paused) {
                 const currentTimeInt = Math.floor(videoPlayer.currentTime);
                 if (currentTimeInt !== lastSavedTime && currentTimeInt % 2 === 0) {
                      localStorage.setItem('resume_' + currentMediaId, videoPlayer.currentTime);
                      lastSavedTime = currentTimeInt;
                 }
            }
        });

        // --- Drag & Drop Helpers ---
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleFileDrop(files) {
            const fileList = Array.from(files);
            if (fileList.length === 0) return;

            const mediaFiles = fileList.filter(file => {
                const name = file.name.toLowerCase();
                return file.type.startsWith('video/') || file.type.startsWith('audio/') || 
                       name.match(/\.(mp4|webm|mkv|avi|mov|ts|wmv|mp3|wav|flac|m4a)$/i);
            });

            const subtitleFiles = fileList.filter(file => {
                return file.name.toLowerCase().endsWith('.vtt') || file.name.toLowerCase().endsWith('.srt');
            });

            // Handle Playlist Logic
            if (mediaFiles.length > 0) {
                if (mediaFiles.length > 1 || playlist.length > 0) {
                    // Add to playlist
                    mediaFiles.forEach(file => {
                        playlist.push({
                            file: file,
                            url: URL.createObjectURL(file),
                            name: file.name
                        });
                    });
                    renderPlaylist();
                    
                    // If playing nothing, start the first added one
                    if (currentPlaylistIndex === -1) {
                        playPlaylistItem(playlist.length - mediaFiles.length);
                    } else {
                        showTemporaryAlert(`Added ${mediaFiles.length} files to queue.`, 'success');
                    }
                    
                    // Show sidebar
                    playlistSidebar.classList.remove('hidden');
                    playlistSidebar.classList.add('flex');
                } else {
                    // Single file drop, direct play
                    loadMediaSource(URL.createObjectURL(mediaFiles[0]), mediaFiles[0].name);
                    videoUrlInput.value = '';
                }
            }

            if (subtitleFiles.length > 0) {
                processSubtitleFile(subtitleFiles[0]); 
            }
            
            if (mediaFiles.length === 0 && subtitleFiles.length === 0) {
                showTemporaryAlert('Unsupported file(s).', 'error');
            }
        }

        // --- Drag & Drop: Main Card ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            mainCard.addEventListener(eventName, handleDragOver, false);
        });

        mainCard.addEventListener('dragenter', (e) => {
            if (videoPlayer.style.display !== 'none' && e.dataTransfer.types.includes('Files')) {
                dragDropOverlay.style.display = 'flex';
            }
        }, false);

        mainCard.addEventListener('dragleave', (e) => {
            if (!mainCard.contains(e.relatedTarget)) {
                dragDropOverlay.style.display = 'none';
            }
        }, false);

        mainCard.addEventListener('drop', (e) => {
            dragDropOverlay.style.display = 'none';
            handleFileDrop(e.dataTransfer.files);
        }, false);

        // --- Drag & Drop: Playlist Sidebar ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            playlistSidebar.addEventListener(eventName, handleDragOver, false);
        });

        playlistSidebar.addEventListener('drop', (e) => {
            // Force playlist mode logic by ensuring playlist has items or treating drop as add
            // We can reuse handleFileDrop which adds to playlist if playlist.length > 0
            // But if empty, handleFileDrop plays directly. We want explicit add here.
            
            e.preventDefault();
            const files = Array.from(e.dataTransfer.files);
            const mediaFiles = files.filter(file => {
                const name = file.name.toLowerCase();
                return file.type.startsWith('video/') || file.type.startsWith('audio/') || 
                       name.match(/\.(mp4|webm|mkv|avi|mov|ts|wmv|mp3|wav|flac|m4a)$/i);
            });

            if (mediaFiles.length > 0) {
                mediaFiles.forEach(file => {
                    playlist.push({
                        file: file,
                        url: URL.createObjectURL(file),
                        name: file.name
                    });
                });
                renderPlaylist();
                showTemporaryAlert(`Added ${mediaFiles.length} files to queue.`, 'success');
                
                // If nothing playing, play first
                if (currentPlaylistIndex === -1) {
                    playPlaylistItem(0);
                }
            }
        }, false);

        // --- Playlist Logic ---
        playlistToggleBtn.addEventListener('click', () => {
            const isHidden = playlistSidebar.classList.contains('hidden');
            if (isHidden) {
                playlistSidebar.classList.remove('hidden');
                playlistSidebar.classList.add('flex');
            } else {
                playlistSidebar.classList.add('hidden');
                playlistSidebar.classList.remove('flex');
            }
        });

        function renderPlaylist() {
            playlistContainer.innerHTML = '';
            playlistCount.textContent = playlist.length;

            if (playlist.length === 0) {
                playlistContainer.innerHTML = `
                    <div class="text-center p-8 text-muted-foreground text-sm">
                        <i data-lucide="ghost" class="h-8 w-8 mx-auto mb-2 opacity-50"></i>
                        <p>Drop multiple files to create a queue</p>
                    </div>`;
                return;
            }

            playlist.forEach((item, index) => {
                const el = document.createElement('div');
                el.className = `flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-colors text-sm group ${index === currentPlaylistIndex ? 'bg-primary/10 text-primary font-medium' : 'hover:bg-secondary'}`;
                
                // Securely create elements
                const iconDiv = document.createElement('div');
                iconDiv.className = 'shrink-0';
                iconDiv.innerHTML = index === currentPlaylistIndex 
                    ? '<i data-lucide="play" class="h-4 w-4 fill-current"></i>' 
                    : `<span class="text-muted-foreground text-xs w-4 inline-block text-center">${index + 1}</span>`;
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'min-w-0 flex-1';
                const nameP = document.createElement('p');
                nameP.className = 'truncate';
                nameP.textContent = item.name; // Secure Text Content
                nameDiv.appendChild(nameP);
                
                const delBtn = document.createElement('button');
                delBtn.className = 'opacity-0 group-hover:opacity-100 hover:text-destructive p-1';
                delBtn.innerHTML = '<i data-lucide="x" class="h-3 w-3"></i>';
                delBtn.onclick = (e) => window.removeFromPlaylist(e, index);
                
                el.appendChild(iconDiv);
                el.appendChild(nameDiv);
                el.appendChild(delBtn);

                el.onclick = (e) => {
                    if(!e.target.closest('button')) playPlaylistItem(index);
                };
                playlistContainer.appendChild(el);
            });
            lucide.createIcons({ root: playlistContainer });
        }

        function playPlaylistItem(index) {
            if (index < 0 || index >= playlist.length) return;
            currentPlaylistIndex = index;
            const item = playlist[index];
            loadMediaSource(item.url, item.name);
            // Explicitly play after loading source from playlist
            videoPlayer.play().catch(e => console.log('Autoplay blocked', e));
            renderPlaylist();
        }

        window.removeFromPlaylist = (e, index) => {
            e.stopPropagation();
            URL.revokeObjectURL(playlist[index].url);
            playlist.splice(index, 1);
            
            if (index === currentPlaylistIndex) {
                currentPlaylistIndex = -1; // Current playing removed
            } else if (index < currentPlaylistIndex) {
                currentPlaylistIndex--; // Shift index
            }
            renderPlaylist();
        };

        // Auto-play next logic based on Mode
        videoPlayer.addEventListener('ended', () => {
            if (playlist.length === 0) return;

            if (playbackMode === 'loop-one') {
                // Handled natively by video.loop = true, but strictly ensuring:
                videoPlayer.play(); 
            } else if (playbackMode === 'loop-all') {
                const nextIndex = (currentPlaylistIndex + 1) % playlist.length;
                playPlaylistItem(nextIndex);
            } else if (playbackMode === 'shuffle') {
                const randomIndex = Math.floor(Math.random() * playlist.length);
                playPlaylistItem(randomIndex);
            } else {
                // Normal
                if (currentPlaylistIndex < playlist.length - 1) {
                    playPlaylistItem(currentPlaylistIndex + 1);
                }
            }
        });

        // --- Keyboard Shortcuts & Feedback ---
        function showFeedback(iconName) {
            try {
                if (feedbackTimeout) clearTimeout(feedbackTimeout);

                // Map FA icons to Lucide
                const iconMap = {
                    'fa-play': 'play',
                    'fa-pause': 'pause',
                    'fa-backward': 'rewind',
                    'fa-forward': 'fast-forward',
                    'fa-volume-up': 'volume-2',
                    'fa-volume-down': 'volume-1',
                    'fa-volume-mute': 'volume-x'
                };

                const lucideName = iconMap[iconName] || 'activity';

                // Manually render SVG for performance/simplicity in this context
                // We use lucide.icons[Name].toSvg()
                // Convert kebab-case to PascalCase for the key
                const camelName = lucideName.split('-').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join('');
                // Special cases
                let lucideKey = camelName;
                if (lucideName === 'volume-2') lucideKey = 'Volume2';
                if (lucideName === 'volume-1') lucideKey = 'Volume1';
                if (lucideName === 'volume-x') lucideKey = 'VolumeX';
                if (lucideName === 'fast-forward') lucideKey = 'FastForward';

                // Fallback
                if (!lucide.icons[lucideKey]) lucideKey = 'Play';

                // Safe check for API
                if (lucide.icons[lucideKey] && typeof lucide.icons[lucideKey].toSvg === 'function') {
                    indicatorIconWrapper.innerHTML = lucide.icons[lucideKey].toSvg({ class: "h-10 w-10 text-foreground" });
                    feedbackIndicator.style.opacity = '1';

                    feedbackTimeout = setTimeout(() => {
                        feedbackIndicator.style.opacity = '0';
                    }, 800);
                }
            } catch (err) {
                console.warn('Feedback Error:', err);
            }
        }

        function handleKeydown(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            if (videoPlayer.style.display === 'none') return;
            let handled = true;

            switch (e.key) {
                case ' ':
                    if (e.repeat) return;
                    videoPlayer.paused ? videoPlayer.play() : videoPlayer.pause();
                    break;
                case 'ArrowLeft':
                    videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 5);
                    showFeedback('fa-backward');
                    break;
                case 'ArrowRight':
                    videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 5);
                    showFeedback('fa-forward');
                    break;
                case 'ArrowUp':
                    videoPlayer.volume = Math.min(1, videoPlayer.volume + 0.1);
                    showFeedback('fa-volume-up');
                    break;
                case 'ArrowDown':
                    videoPlayer.volume = Math.max(0, videoPlayer.volume - 0.1);
                    showFeedback('fa-volume-down');
                    break;
                case 'm': case 'M':
                    if (e.repeat) return;
                    videoPlayer.muted = !videoPlayer.muted;
                    showFeedback(videoPlayer.muted ? 'fa-volume-mute' : 'fa-volume-up');
                    break;
                case 'f': case 'F':
                    if (e.repeat) return;
                    const container = videoPlayer.parentElement;
                    if (!document.fullscreenElement) container.requestFullscreen();
                    else document.exitFullscreen();
                    break;
                default: handled = false;
            }
            if (handled) e.preventDefault();
        }

        document.addEventListener('keydown', handleKeydown);
        videoPlayer.addEventListener('play', () => {
            initAudioVisualizer();
            showFeedback('fa-play');
        });
        videoPlayer.addEventListener('pause', () => showFeedback('fa-pause'));

        // --- Audio Visualizer Logic ---
        let dataArray;
        let bufferLength;

        function randomizeVisualizer() {
            const styles = ['bars', 'mirror', 'wave'];
            visualizerStyle = styles[Math.floor(Math.random() * styles.length)];
            visualizerHue = Math.floor(Math.random() * 360);
            visualizerSaturation = Math.floor(Math.random() * 40) + 60; // 60-100%
            visualizerLightness = Math.floor(Math.random() * 30) + 40; // 40-70%
            console.log(`Visualizer Mode: ${visualizerStyle}, Hue: ${visualizerHue}, Sat: ${visualizerSaturation}%, Light: ${visualizerLightness}%`);
        }

        function drawVisualizer() {
            if (videoPlayer.paused || videoPlayer.ended) {
                isVisualizerRunning = false;
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            requestAnimationFrame(drawVisualizer);
            isVisualizerRunning = true;

            if (analyser && dataArray) {
                if (visualizerStyle === 'wave') {
                    analyser.getByteTimeDomainData(dataArray);
                } else {
                    analyser.getByteFrequencyData(dataArray);
                }

                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                const width = canvas.width;
                const height = canvas.height;

                if (visualizerStyle === 'bars') {
                    const barWidth = (width / bufferLength) * 2.5;
                    let barHeight;
                    let x = 0;
                    for(let i = 0; i < bufferLength; i++) {
                        barHeight = (dataArray[i] / 255) * height;
                        canvasCtx.fillStyle = `hsla(${visualizerHue}, ${visualizerSaturation}%, ${visualizerLightness}%, ${(barHeight/height) + 0.2})`;
                        canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }
                } else if (visualizerStyle === 'mirror') {
                    const barWidth = (width / bufferLength) * 2;
                    let barHeight;
                    let x = width / 2; // Start center
                    for(let i = 0; i < bufferLength; i++) {
                        barHeight = (dataArray[i] / 255) * (height / 1.5);
                        canvasCtx.fillStyle = `hsla(${visualizerHue}, ${visualizerSaturation}%, ${visualizerLightness}%, ${(barHeight/height) + 0.3})`;
                        
                        // Right side
                        canvasCtx.fillRect(width/2 + (i * barWidth), (height - barHeight)/2, barWidth, barHeight);
                        // Left side
                        canvasCtx.fillRect(width/2 - (i * barWidth) - barWidth, (height - barHeight)/2, barWidth, barHeight);
                    }
                } else if (visualizerStyle === 'wave') {
                    canvasCtx.lineWidth = 2;
                    canvasCtx.strokeStyle = `hsla(${visualizerHue}, ${visualizerSaturation}%, ${visualizerLightness}%, 0.8)`;
                    canvasCtx.beginPath();
                    const sliceWidth = width * 1.0 / bufferLength;
                    let x = 0;
                    for(let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i] / 128.0;
                        const y = v * height / 2;
                        if(i === 0) canvasCtx.moveTo(x, y);
                        else canvasCtx.lineTo(x, y);
                        x += sliceWidth;
                    }
                    canvasCtx.lineTo(canvas.width, canvas.height/2);
                    canvasCtx.stroke();
                }
            }
        }

        function initAudioVisualizer() {
            // Only run if audio file
            if (!isAudioFile) return;

            if (!audioCtx) {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioCtx = new AudioContext();
                    analyser = audioCtx.createAnalyser();
                    audioSource = audioCtx.createMediaElementSource(videoPlayer);
                    audioSource.connect(analyser);
                    analyser.connect(audioCtx.destination);
                    
                    analyser.fftSize = 256;
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                } catch (e) {
                    console.warn("Audio Context init failed:", e);
                    return;
                }
            }

            // Resume context if suspended (Autoplay Policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            // Restart loop if not running
            if (!isVisualizerRunning && !videoPlayer.paused) {
                drawVisualizer();
            }
        }
        
        // Handle Resize for Canvas
        window.addEventListener('resize', () => {
             if(canvas) {
                 canvas.width = canvas.offsetWidth;
                 canvas.height = canvas.offsetHeight;
             }
        });

        // --- Video Filter Logic ---
        function applyVideoFilters() {
            const b = videoBrightnessInput.value;
            const c = videoContrastInput.value;
            const s = videoSaturationInput.value;

            videoPlayer.style.filter = `brightness(${b}%) contrast(${c}%) saturate(${s}%)`;
            
            valBrightness.textContent = b + '%';
            valContrast.textContent = c + '%';
            valSaturation.textContent = s + '%';
        }

        [videoBrightnessInput, videoContrastInput, videoSaturationInput].forEach(input => {
            input.addEventListener('input', applyVideoFilters);
        });

        // --- Reset Settings Logic ---
        resetSettingsBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to reset all settings?')) {
                localStorage.removeItem(SUB_SETTINGS_KEY);
                loadSubtitleSettings(); // Reloads defaults
                
                // Reset Video Filters
                videoBrightnessInput.value = 100;
                videoContrastInput.value = 100;
                videoSaturationInput.value = 100;
                applyVideoFilters();

                showTemporaryAlert('Settings reset to defaults.', 'success');
            }
        });

        // --- Help Modal Logic ---
        function toggleHelpModal() {
            const isHidden = helpModal.classList.contains('hidden');
            if (isHidden) {
                helpModal.classList.remove('hidden');
                helpModal.classList.add('flex');
            } else {
                helpModal.classList.add('hidden');
                helpModal.classList.remove('flex');
            }
        }

        helpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleHelpModal();
        });

        closeHelpBtn.addEventListener('click', toggleHelpModal);

        // Close modal when clicking outside
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                toggleHelpModal();
            }
        });

        loadSubtitleSettings();
        setPlayerMode('video');

        // Show welcome toast
        setTimeout(() => {
            showTemporaryAlert('Ready to load content. Drag and drop a file!', 'info');
        }, 500);

        // --- Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

    </script>
</body>
</html>
